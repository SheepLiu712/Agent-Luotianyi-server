from ..llm.llm_module import LLMModule
from ..llm.prompt_manager import PromptManager
from ..music.singing_manager import SingingManager
from typing import Dict, Any, List, Optional
import time
import json
from typing import Tuple, Dict, List 
from ..types.tool_type import MyTool
from ..types.planner_type import PlanningStep, ReplyIntensity, SingingAction
from ..utils.logger import get_logger
import random

class Planner:
    def __init__(
        self, config: Dict[str, Any], prompt_manager: PromptManager, singing_manager: SingingManager
    ) -> None:
        self.logger = get_logger(__name__)
        self.config = config
        self.llm = LLMModule(config["llm_module"], prompt_manager)
        self.variables: List[str] = self.llm.prompt_template.get_variables()
        self.all_tools: Dict[str, MyTool] = {}
        self.singing_manager = singing_manager
        self._init_static_variables_sync()

    def register_tools(self, tools: Dict[str, MyTool]) -> None:
        self.all_tools.update(tools)
        self.logger.info(f"Registered tools: {list(tools.keys())}")
        

    async def generate_response(self, user_input: str, conversation_history: str = "", retrieved_knowledge: List[str] = "") -> PlanningStep:
        init_planning = await self.get_init_planning_step(user_input, conversation_history, retrieved_knowledge)

        if init_planning.singing_action == SingingAction.PROPOSE_SINGING:
            if can_sing :=  self.singing_manager.can_i_sing_song(init_planning.singing_song):
                init_planning.singing_segment = random.choice(can_sing) # 从 can_sing中随机选择一个片段
            else:
                init_planning.singing_song = None  # 如果不能唱，清空歌曲名称，改为模糊的建议唱歌
        elif init_planning.singing_action == SingingAction.TRY_SINGING:
            if can_sing :=  self.singing_manager.can_i_sing_song(init_planning.singing_song):
                init_planning.singing_segment = random.choice(can_sing) # 从 can_sing中随机选择一个片段
                
                init_planning.singing_lyrics = self.singing_manager.get_segment_lyrics(
                    init_planning.singing_song, init_planning.singing_segment)
            else:
                init_planning.singing_action = SingingAction.NO_SINGING # 如果不能唱，改为不唱歌
                    
        return init_planning

    async def get_init_planning_step(self, user_input: str = "", conversation_history: str = "", retrieved_knowledge: List[str] = "") -> PlanningStep:
        current_time = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        persona = self.persona

        # 调用异步的 LLM 生成接口
        try:
            response = await self.llm.generate_response(
                user_message=user_input,
                persona=persona,
                conversation_history=conversation_history,
                knowledge="\n".join(retrieved_knowledge),
                current_time=current_time,
                use_json = True
            )
        except Exception as e:
            import traceback
            self.logger.error(f"Error during LLM response generation: {e} \n{traceback.format_exc()}")
            response = None
        if not response:
            self.logger.warning("No response generated by LLM.")
            return PlanningStep(
                reply_intensity=ReplyIntensity.NORMAL,
                reply_description="普通地回复用户的最新对话内容。"
            )
        self.logger.debug(f"Planner LLM response: {response}")
        
        try:
            # Handle potential markdown code blocks
            json_str = response
            if "```json" in response:
                json_str = response.split("```json")[1].split("```")[0].strip()
            elif "```" in response:
                json_str = response.split("```")[1].split("```")[0].strip()
                
            response_json = json.loads(json_str)
            
            # Parse 'chat' section
            chat_data = response_json.get("chat", {})
            reply_intensity_str = chat_data.get("reply_intensity", "normal").lower()
            reply_description = chat_data.get("description", "普通地回复用户的最新对话内容。")
            
            try:
                reply_intensity = ReplyIntensity(reply_intensity_str)
            except ValueError:
                self.logger.warning(f"Unknown reply_intensity: {reply_intensity_str}, defaulting to NORMAL")
                reply_intensity = ReplyIntensity.NORMAL
                
            # Parse 'singing' section
            singing_data = response_json.get("singing", {})
            singing_action_str = singing_data.get("action", "no_singing").lower()
            song_name = singing_data.get("song_name", None)
            if song_name is not None:
                song_name = song_name.strip().strip("《》")  # 去除多余空格和书名号
            
            try:
                singing_action = SingingAction(singing_action_str)
            except ValueError:
                self.logger.warning(f"Unknown singing_action: {singing_action_str}, defaulting to NO_SINGING")
                singing_action = SingingAction.NO_SINGING
                
            return PlanningStep(
                reply_intensity=reply_intensity,
                reply_description=reply_description,
                singing_action=singing_action,
                singing_song=song_name
            )
            
        except json.JSONDecodeError as e:
            self.logger.error(f"Failed to parse LLM response as JSON: {response}. Error: {e}")
            return PlanningStep(
                reply_intensity=ReplyIntensity.NORMAL,
                reply_description="普通地回复用户的最新对话内容。",
            )
        except Exception as e:
            self.logger.error(f"Error parsing planner response: {e}")
            return PlanningStep(
                reply_intensity=ReplyIntensity.NORMAL,
                reply_description="普通地回复用户的最新对话内容。",
            )

        

    def _init_static_variables_sync(self) -> None:
        """获取在prompt中不变的变量： persona, response_requirements, response_format (同步版本)"""
        static_variables_file = self.config.get("static_variables_file", None)
        if not static_variables_file:
            raise ValueError("static_variables_file must be provided in main_chat config")
        with open(static_variables_file, "r", encoding="utf-8") as f:
            static_vars: Dict[str, Any] = json.load(f)

        self.persona = static_vars.get("persona")